\section{Introduction}

High-performance multicores are needed to deliver the increasing performance demands of highly-automated and autonomous systems in automotive, avionics and space, among other domains. However, performance demands come along with safety requirements in those domains, as dictated in corresponding functional safety standards (e.g., ISO26262 in automotive~\cite{ISO26262}).
One such requirement for high-integrity systems consists of avoiding the unacceptable risk (aka unreasonable risk in ISO26262 terminology) of \emph{common cause failures} (CCFs), where a CCF stands for a failure caused by a single fault affecting all redundant components analogously. Note that CCFs relate to the effect, i.e. the failure, not to the source, i.e. the fault. Hence, CCFs could be caused, for instance, by a soft error affecting clock logic of two cores, or by a defect causing voltage sporadic droops.

CCFs are generally mitigated by using diverse redundancy~\cite{ClassicDiversity}, so that, even if a fault affects all redundant components (e.g., a voltage droop), since they have different state, potential errors differ and can be detected. Error correction codes (ECC) for storage, Cyclic Redundancy Coding (CRC) for communications, and lockstepping for computation are the most common solutions~\cite{SergiIOLTS}. The latter -- lockstep execution~\cite{STlockstep,infineon_aurix,Iturbe2019,paper1} -- is the focus of this work. 

Lockstep execution (hardware-only) builds upon identical redundant cores running the same software with some staggering -- i.e. the head core runs $N$ cycles ahead of the trail one -- being one of them the one effectively sending and receiving external signals (e.g., load/store data, interrupts, etc.). The outputs of the other core are just used for comparison for error detection reasons. However, in such a scheme only one core is visible at user level, thus not allowing to use both cores to run independent tasks if lockstep execution is not needed.

A light-weight lockstep execution scheme has been recently proposed to overcome the limitations of regular hardware-only lockstepping~\cite{SergiDFT}. Such solution builds on software redundancy (i.e., the task is run redundantly from the software layers), and on a software monitor enforcing sufficient staggering between redundant processes. However, due to the slow software monitoring loop, staggering is significant (e.g., 100$\mu$s - 1ms), which imposes a performance loss as significant as such staggering (as opposed to the hardware-only solution whose staggering is few cycles), and requires an additional core to run the monitor periodically.

This paper presents extensive details and evaluation of SafeDE, a \underline{D}iversity \underline{E}nforcement hardware module overcoming the limitations of the previous two schemes. In particular, SafeDE, which we first introduced in \cite{SafeDE} and extend in this work, implements the light-weight lockstep execution scheme, but with a hardware monitor (SafeDE module) rather than a software module, hence allowing for few-cycles staggering and not needing any additional core to run any monitor software. Moreover, the integration of SafeDE does not require modifying the cores being monitored, hence being a lowly intrusive solution.
The main contributions of this work are as follows:
\begin{itemize}
\item We present SafeDE, the monitoring module to enable lowly-intrusive diverse redundancy with a flexible scheme that can be enabled or disabled at convenience. We further detail how to extend it to arbitrary redundancy (e.g., with 3 or more cores instead of only 2).
\item We implement it at VHDL in a SoC for the space domain based on CAES Gaisler's NOEL-V cores~\cite{SELENEgit}, and provide details on its bare metal and Linux integrations.
\item We assess SafeDE's performance and area overheads, as well as effectiveness through a fault injection campaign.
\end{itemize}

The rest of the paper is organized as follows. Background is presented in Section~\ref{sec:back}. SafeDE and its hardware and software integrations are introduced in Section~\ref{sec:dimmo}. Section~\ref{sec:eval} evaluates SafeDE. Related work is presented in Section~\ref{sec:rel}. Section~\ref{sec:concl} summarizes this work.
