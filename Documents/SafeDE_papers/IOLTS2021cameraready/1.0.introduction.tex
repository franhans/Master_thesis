\section{Introduction}

Increased autonomy levels and improved features in cars, satellites and planes lead to increasing performance demands for those systems. Existing multicores and accelerators deliver the level of performance needed. However, safety-related systems such as those in automotive, space and avionics need to meet specific safety requirements for their adoption. Those requirements are dictated by the specific safety integrity level of the functionality at hand, and are particularly demanding for the highest levels (e.g. Automotive Safety Integrity Level, ASIL, D in automotive~\cite{ISO26262}). 

A key safety requirement for the highest integrity level systems is the capability of not causing a failure due to a single fault. Those faults are normally mitigated by means of diverse redundancy~\cite{ClassicDiversity}, so that redundancy exists but it is sufficiently diverse so that a single fault affecting all replicas would cause different effects, thus allowing, at least, detecting the fault. 
%Such fault detection should allow recovering or reaching a safe state before the fault leads to a failure. 

Solutions for diverse redundancy often relate to Error Correction Codes (ECC) for storage and Cyclic Redundancy Coding (CRC) for communications~\cite{SergiIOLTS}. Computing elements (e.g. cores), instead, usually require full replication and thus, resort to dual (DMR)~\cite{Mukherjee2002,Gomaa2003,dynamic_coupled_cores} or triple modular redundancy (TMR)~\cite{Iturbe2019}. However, such redundancy is not enough and diversity is also needed to avoid that a single fault (e.g. a voltage droop or a permanent fault) affects redundant instances identically. Such diverse redundancy is achieved with lockstepping, where two (or more) identical cores execute the same software redundantly, but with some staggering among them, so that the state of the cores differs at any point in time, and thus, a fault cannot produce the same error in all redundant copies, which could go unnoticed otherwise.

Lockstepping, in the form of Dual Core LockStepping (DCLS)~\cite{infineon_aurix,STlockstep,RendundancyASILD}, is generally implemented at hardware level tying two cores together operating with few cycles of staggering (i.e. the head core executes the same software $N$ cycles ahead of the trail core). External requests are generated by one of the cores (e.g. head one), but not sent until compared to those of the other core (e.g. trail one). Upon a match, loads, stores, interrupts and any other type of request is sent, but just once (not redundantly). Responses are duplicated and delivered to both cores preserving the staggering (i.e. delivering them $N$ cycles later to the trail core). This ensures consistent states across lockstepped cores, but with some staggering to preserve diversity. Such a solution, however, makes only one of the cores be visible at software level, and precludes the user from using those cores independently.
%implies using modified cores w.r.t. those used without lockstepping, and precludes the ability to use those cores to run different software not needing lockstepping.

Light-weight software-only lockstepping has been proposed to reduce the cost of full lockstepping~\cite{SergiDFT}. Such light-weight lockstepping resorts to software redundancy, and to the existence of a software monitor enforcing staggering across redundant threads. While such a solution has been proven effective, and compatible with Commercial Off-The-Shelf (COTS) processors, it requires native lockstepping (hardware-based) for the core running the monitor, and imposes some non-negligible staggering (e.g. 100$\mu$s) to allow the monitor to collect information of the progress of redundant threads without causing too high relative interference.

Overall, both hardware-based and light software-based lockstepping pose a number of limitations to achieve diverse redundancy. This paper, addresses this challenge by proposing a different tradeoff achieving most of the benefits of both approaches with low cost.

This paper presents \emph{SafeDE}\footnote{Available as an open-source component in https://bsccaos.github.io~\cite{SafeTIWebsite}.}, a \underline{D}iversity \underline{E}nforcement hardware module providing light-lockstep support by means of a non-intrusive and flexible (programmable) hardware module that preserves staggering across cores running redundant threads, thus bringing time diversity. In particular, SafeDE is a tiny hardware module performing the same monitoring tasks as the software-only solution, but with a much lower staggering (just few cycles instead of 100$\mu$s), and without requiring native lockstepped cores. 
%Of course, while the software-only solution can be applied on COTS, SafeDE needs to be integrated in the SoC.
Compared to native hardware lockstepping, SafeDE can be integrated without modifying IP cores, thus with limited intrusiveness, and allows using cores independently instead of always in lockstep mode.
In particular, the contributions of this paper are as follows:
\begin{itemize}
\item We present SafeDE, a new hardware/software scheme for efficient, flexible and lowly-intrusive light lockstepping to achieve diverse redundancy.
\item We implement and verify SafeDE in VHDL.
\item We successfully integrate SafeDE in a space SoC based on Cobham Gaisler's NOEL-V cores, implemented in a FPGA, which is already a commercial setup for this platform reaching commercial readiness by early 2022~\cite{DeRISCjournal}.
\end{itemize}

The rest of the paper is organized as follows. Section~\ref{sec:back} provides some background. SafeDE is presented in Section~\ref{sec:dimmo} and evaluated in Section~\ref{sec:eval}. Section~\ref{sec:rel} reviews related work. Section~\ref{sec:concl} concludes this paper.

