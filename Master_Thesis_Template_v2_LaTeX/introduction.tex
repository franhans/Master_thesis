\clearpage
\newpage
\section{Introduction}

{\color{magenta}
{An Introduction that clearly states the rationale of the thesis that includes:}

\begin{enumerate}
\item {Statement of purpose (objectives).}
\item {Requirements and specifications.}
\item {Methods and procedures, citing if this work is a continuation of another project or it uses applications, algorithms,
software or hardware previously developed by other authors.}
\item {Work plan with tasks, milestones and a Gantt diagram.}
\item {Description of the deviations from the initial plan and incidences that may have occurred. }
\end{enumerate}
}

\bigskip


\subsection{Context and Objectives}

High-performance multicores are needed to deliver the increasing performance demands of highly-automated and autonomous systems in automotive, avionics and space, among other domains. However, performance demands come along with safety requirements in those domains, as dictated in corresponding functional safety standards (e.g., ISO26262 in automotive~\cite{ISO26262}).
One such requirement for high-integrity systems consists of deploying redundancy to detect errors, but avoiding the unacceptable risk (aka unreasonable risk in ISO26262 terminology) of \emph{common cause failures} (CCFs), where a CCF stands for a failure caused by a single fault affecting all redundant components analogously. Note that CCFs relate to the effect, i.e. the failure, not to the source, i.e. the fault. Hence, CCFs could be caused, for instance, by a soft error affecting clock logic of two cores, or by a defect causing voltage sporadic droops. If such a single fault drives the redundant items (e.g. two cores running the same program redundantly) to the same error, so that it cannot be detected by comparing the results of the redundant items, then it is said that such fault induces a CCF.

CCFs are generally mitigated by using diverse redundancy~\cite{ClassicDiversity}, so that, even if a fault affects all redundant components (e.g., a voltage droop), since they have different state, potential errors differ and can be detected. Error correction codes (ECC) for storage, Cyclic Redundancy Coding (CRC) for communications, and lockstepping for computation are the most common solutions~\cite{alcaide2019software}. ECC and CRC build on generating a form of signature of the data protected, being such signature the result of applying some operations on the data. Hence, the signature and data have different length and different values (and hence, are diverse). If a fault, such a voltage droop, when reading, storing or transmitting data causes perturbations that lead to altered values read, written or transmitted, the likelihood of the signature matching the data tends to zero (e.g., chances of matching may easily be $\frac{1}{2^K}$ for $K$-bit signatures), and hence the error is, at least, detected.
Nevertheless, the focus of this thesis is lockstep execution for computation~\cite{STlockstep,infineon2012aurix,iturbe2019arm,paper1}. 

Lockstep execution (hardware-only) builds upon identical redundant cores running the same software with some staggering -- i.e. the head core runs $N$ cycles ahead of the trail one. Such staggering makes that, at any point in time, the state and activity across redundant cores is dissimilar, and hence, diverse redundancy is attained as long as some staggering holds.
In lockstep execution, one of the cores effectively sends and receives external signals (e.g., load/store data, interrupts, etc.). The outputs of the other core are just used for comparison for error detection reasons. However, in such a scheme only one core is visible at user level, thus not allowing to use both cores to run independent tasks if lockstep execution is not needed.

A light-weight lockstep execution scheme has been recently proposed to overcome the limitations of regular hardware-only lockstepping~\cite{alcaide2020software}. Such solution builds on software redundancy (i.e., the task is run redundantly from the software layers), and on a software monitor enforcing sufficient staggering between redundant processes. However, due to the slow software monitoring loop, staggering is significant (e.g., 100$\mu$s - 1ms), which imposes a performance loss as significant as such staggering (as opposed to the hardware-only solution whose staggering is few cycles), and requires an additional core to run the monitor periodically.

The objectives of this thesis consist of devising, integrating in an SoC, and evaluating a hardware module that achieves diverse redundancy for computation, but overcoming the main disadvantages of hardware-only lockstep execution and light-weight software-only lockstep execution. 
%In particular, we aim at designing and evaluating the hardware counterpart of the software-only solution. 
Therefore, this thesis presents SafeDE, a \underline{D}iversity \underline{E}nforcement hardware module overcoming the limitations of the previous two schemes. In particular, SafeDE implements the light-weight lockstep execution scheme, but with a hardware monitor (SafeDE module) rather than a software module, hence allowing for few-cycles staggering and not needing any additional core to run any monitor software. Moreover, the integration of SafeDE does not require modifying the cores being monitored, hence being a lowly intrusive solution.
The main contributions of this work are as follows:
\begin{itemize}
\item We present SafeDE, the monitoring module to enable lowly-intrusive diverse redundancy with a flexible scheme that can be enabled or disabled at convenience. We further detail how to extend it to arbitrary redundancy (e.g., with 3 or more cores instead of only 2).
\item We implement it at VHDL in a SoC for the space domain based on CAES Gaisler's NOEL-V cores~\cite{SELENEgit}, and provide details on its bare metal and Linux integrations.
\item We assess SafeDE's performance and area overheads, as well as effectiveness through a fault injection campaign.
\end{itemize}



\subsection{Requirements and Specifications}

This work aims at developing SafeDE, a hardware module providing support for light-weight diverse redundancy. The requirements for such module are as follows:
\begin{itemize}
\item It must allow cores executing redundant tasks have a staggering much lower than that needed by the software-only solution. In general, a staggering in the order of some hundreds (or even few thousands) of cycles would be considered low enough. 
\begin{itemize}
\item As we show later in this document, we achieved this goal by setting a staggering of 20 instructions which, in practice, execute in some tens of cycles.
\end{itemize}
\item The module can be enabled and disabled by the end user within its applications so that lockstep execution is used only when needed. 
\begin{itemize}
\item As we show later in this document, activation and deactivation of the module is achieved by setting/resetting specific registers of the module that can be controlled by the end user from its own applications.
\end{itemize}
\item Hardware costs, typically in terms of area, must be low (e.g., below 5\% of the overall SoC).
\begin{itemize}
\item As we show later in this document, the cost in the FPGA implementation of the SoC is well below 1\% to make 2 cores operate in lockstep mode. If further cores are incorporated into the SoC, other SafeDE module instances should be added (one per pair of cores). Hence, the relative cost of the SafeDE module is expected to remain quite constant in relative terms with respect to the overall SoC.
\end{itemize}
\end{itemize}


\subsection{Methods, Procedures and Previous Work}

